#!/usr/bin/env bash
# @license
# This file is part of Bott.
#
# This project is dual-licensed:
# - Non-commercial use: AGPLv3 (see LICENSE file for full text).
# - Commercial use: Proprietary License (contact D@nielLaCos.se for details).
#
# Copyright (C) 2025 DanielLaCos.se

set -euo pipefail

# Get script directory and source utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils/log.sh"
source "$SCRIPT_DIR/utils/checks.sh"

# Default values
ENV="${ENV:-production}"
GCP_SERVICE_NAME="${GCP_SERVICE_NAME:-bott-$ENV}"
ENV_FILE="${ENV_FILE:-.env.$ENV}"
ALLOW_UNAUTHENTICATED="${ALLOW_UNAUTHENTICATED:-true}"
DEFAULT_REGION="us-central1"

# Ensure user is authenticated
ensure_authenticated() {
  if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" 2>/dev/null | grep -q .; then
    warn_log "Not authenticated with gcloud."
    info_log "Running: gcloud auth application-default login"
    gcloud auth application-default login
  else
    info_log "Already authenticated with gcloud"
  fi
}

# Setup or verify GCP project
setup_project() {
  local project_id="${GOOGLE_PROJECT_ID:-}"
  
  if [ -z "$project_id" ]; then
    warn_log "GOOGLE_PROJECT_ID not set in environment file."
    read -r -p "Enter your GCP Project ID (or press Enter to auto-generate): " project_id
    
    if [ -z "$project_id" ]; then
      # Auto-generate a unique project ID using timestamp and openssl for better uniqueness
      local unique_suffix
      unique_suffix=$(openssl rand -hex 4 2>/dev/null || echo "$RANDOM$RANDOM")
      project_id="bott-$(date +%s)-${unique_suffix}"
      info_log "Auto-generating project ID: $project_id"
      info_log "Creating new project: $project_id"
      
      if gcloud projects create "$project_id" 2>/dev/null; then
        info_log "Project created successfully: $project_id"
      else
        error_log "Failed to create project. You may need to provide a unique project ID."
        read -r -p "Enter a unique GCP Project ID: " project_id
      fi
    fi
    
    export GOOGLE_PROJECT_ID="$project_id"
    
    # Update .env file with the project ID
    if [ -f "$ENV_FILE" ]; then
      if grep -q "^GOOGLE_PROJECT_ID=" "$ENV_FILE"; then
        # Use | as delimiter to avoid issues with special characters
        sed -i.bak "s|^GOOGLE_PROJECT_ID=.*|GOOGLE_PROJECT_ID=$project_id|" "$ENV_FILE"
      else
        echo "GOOGLE_PROJECT_ID=$project_id" >> "$ENV_FILE"
      fi
      rm -f "${ENV_FILE}.bak"
      info_log "Updated $ENV_FILE with GOOGLE_PROJECT_ID=$project_id"
    fi
  fi
  
  # Set the project
  info_log "Setting active project to: $GOOGLE_PROJECT_ID"
  gcloud config set project "$GOOGLE_PROJECT_ID" 2>/dev/null || true
  
  # Check if project exists
  if ! gcloud projects describe "$GOOGLE_PROJECT_ID" &>/dev/null; then
    error_log "Project $GOOGLE_PROJECT_ID does not exist or you don't have access to it."
    exit 1
  fi
  
  info_log "Project verified: $GOOGLE_PROJECT_ID"
}

# Enable required APIs
enable_apis() {
  info_log "Enabling required APIs..."
  
  local apis=(
    "aiplatform.googleapis.com"
    "storage.googleapis.com"
    "run.googleapis.com"
    "artifactregistry.googleapis.com"
    "cloudbuild.googleapis.com"
  )
  
  for api in "${apis[@]}"; do
    if gcloud services list --enabled --filter="name:$api" --format="value(name)" 2>/dev/null | grep -q "$api"; then
      info_log "API already enabled: $api"
    else
      info_log "Enabling API: $api"
      if ! gcloud services enable "$api" --project="$GOOGLE_PROJECT_ID" 2>&1; then
        warn_log "Failed to enable $api"
        warn_log "This may be due to:"
        warn_log "  - Billing not enabled on the project"
        warn_log "  - Insufficient permissions"
        warn_log "  - API not available in your region"
        warn_log "You may need to enable this manually in the GCP Console"
      fi
    fi
  done
}

# Configure service account permissions
configure_service_account() {
  info_log "Configuring service account permissions..."
  
  # Get the Cloud Build service account
  local project_number
  project_number=$(gcloud projects describe "$GOOGLE_PROJECT_ID" --format="value(projectNumber)" 2>/dev/null || echo "")
  
  if [ -z "$project_number" ]; then
    warn_log "Could not determine project number. Skipping IAM configuration."
    return 0
  fi
  
  local service_account="${project_number}@cloudbuild.gserviceaccount.com"
  info_log "Service account: $service_account"
  
  local roles=(
    "roles/aiplatform.user"
    "roles/storage.objectAdmin"
  )
  
  for role in "${roles[@]}"; do
    info_log "Adding role: $role"
    gcloud projects add-iam-policy-binding "$GOOGLE_PROJECT_ID" \
      --member="serviceAccount:$service_account" \
      --role="$role" \
      2>/dev/null || warn_log "Failed to add role $role (may already exist)"
  done
}

# Check if .env.production file exists
check_env_file() {
  if [ ! -f "$ENV_FILE" ]; then
    error_log "Environment file '$ENV_FILE' not found."
    info_log "Please create it from .env.example:"
    info_log "  cp .env.example $ENV_FILE"
    exit 1
  fi
  info_log "Environment file '$ENV_FILE' found"
}

# Validate required environment variables in .env file
validate_env_vars() {
  local required_vars=("GOOGLE_PROJECT_ID" "GOOGLE_PROJECT_LOCATION")
  local missing_vars=()

  # Source the env file to check for required variables
  while IFS='=' read -r key value; do
    # Skip comments and empty lines
    [[ $key =~ ^#.*$ ]] && continue
    [[ -z $key ]] && continue
    
    # Remove leading/trailing whitespace and quotes from value
    value=$(echo "$value" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")
    
    # Export the variable
    export "$key=$value"
  done < "$ENV_FILE"

  for var in "${required_vars[@]}"; do
    if [ -z "${!var:-}" ]; then
      missing_vars+=("$var")
    fi
  done

  if [ ${#missing_vars[@]} -gt 0 ]; then
    error_log "Missing required environment variables in $ENV_FILE:"
    for var in "${missing_vars[@]}"; do
      echo "  - $var"
    done
    exit 1
  fi

  info_log "All required environment variables are set"
}

# Get or prompt for region
get_region() {
  if [ -z "${REGION:-}" ]; then
    info_log "No REGION environment variable set. Using default: $DEFAULT_REGION"
    REGION="$DEFAULT_REGION"
    export REGION
  fi
  info_log "Deploying to region: $REGION"
}

# Deploy to Cloud Run
deploy() {
  info_log "Starting deployment to Google Cloud Run..."
  info_log "Service: $GCP_SERVICE_NAME"
  info_log "Region: $REGION"
  
  local deploy_args=(
    "run" "deploy" "$GCP_SERVICE_NAME"
    "--source" "."
    "--region" "$REGION"
    "--project" "$GOOGLE_PROJECT_ID"
    "--env-vars-file" "$ENV_FILE"
  )

  # Add platform and other options from app.json
  deploy_args+=(
    "--platform" "managed"
    "--cpu" "1"
    "--memory" "1.5Gi"
    "--max-instances" "1"
    "--port" "8080"
  )

  # Note: ALLOW_UNAUTHENTICATED controls public access to the Cloud Run service.
  # Set to "false" for internal services that require authentication.
  if [ "$ALLOW_UNAUTHENTICATED" = "true" ]; then
    deploy_args+=("--allow-unauthenticated")
  fi

  info_log "Executing: gcloud ${deploy_args[*]}"
  
  local exit_code=0
  if gcloud "${deploy_args[@]}"; then
    info_log "Deployment successful!"
    
    # Get the service URL
    SERVICE_URL=$(gcloud run services describe "$GCP_SERVICE_NAME" --region="$REGION" --project="$GOOGLE_PROJECT_ID" --format="value(status.url)" 2>/dev/null || echo "")
    if [ -n "$SERVICE_URL" ]; then
      info_log "Service URL: $SERVICE_URL"
    fi
  else
    error_log "Deployment failed!"
    exit_code=1
  fi
  
  return $exit_code
}

# Main execution
main() {
  info_log "Bott Deployment Script"
  info_log "======================"
  
  check_gcloud
  info_log "gcloud CLI found"
  ensure_authenticated
  check_env_file
  validate_env_vars
  setup_project
  enable_apis
  configure_service_account
  get_region
  
  if deploy; then
    echo ""
    info_log "Deployment complete!"
    info_log "To view logs, run: ./scripts/logs"
    exit 0
  else
    exit 1
  fi
}

# Run main function
main "$@"
