/**
 * @license
 * This file is part of Bott.
 *
 * This project is dual-licensed:
 * - Non-commercial use: AGPLv3 (see LICENSE file for full text).
 * - Commercial use: Proprietary License (contact D@nielLaCos.se for details).
 *
 * Copyright (C) 2025 DanielLaCos.se
 */

import {
  STORAGE_FETCH_TIME_LIMIT_MS,
  STORAGE_FILE_ROOT,
  STORAGE_FILE_WORD_LIMIT,
} from "@bott/constants";
import {
  BOTT_ATTACHMENT_TYPE_LOOKUP,
  BottAttachmentType,
  type BottEvent,
  type BottEventAttachment,
} from "@bott/events";
import { join } from "@std/path";

import { throwIfUnsafeFileSize, throwIfUnsafeUrl } from "../validation.ts";
import {
  prepareAudioAsOpus,
  prepareDynamicImageAsMp4,
  prepareStaticImageAsWebp,
} from "./ffmpeg.ts";
import { prepareHtmlAsMarkdown } from "./html.ts";

const UNNAMED_FILE_PREFIX = "unnamed";

/**
 * Prepares an attachment from a remote URL by downloading, storing raw, and compressing.
 * @param sourceUrl The remote URL to fetch from
 * @param parentEvent The parent event this attachment belongs to
 * @returns Fully prepared attachment with both raw and compressed files
 */
export async function prepareAttachmentFromUrl(
  sourceUrl: URL,
  parentEvent: BottEvent,
): Promise<BottEventAttachment> {
  const fileSystemRoot = getFileSystemRoot();

  throwIfUnsafeUrl(sourceUrl);

  const attachmentId = crypto.randomUUID();

  console.debug(`Fetching attachment from URL: ${sourceUrl}`);

  const response = await fetch(sourceUrl, {
    signal: AbortSignal.timeout(STORAGE_FETCH_TIME_LIMIT_MS),
    redirect: "follow",
    headers: {
      "User-Agent": "Bott",
    },
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data = new Uint8Array(await response.arrayBuffer());

  throwIfUnsafeFileSize(data);

  const type = response.headers.get("content-type")?.split(";")[0].trim() ?? "";

  if (!Object.values(BottAttachmentType).includes(type as BottAttachmentType)) {
    throw new Error(`Unsupported content type: ${type}`);
  }

  const rawFile = new File(
    [data],
    `${attachmentId}.raw.${type.split("/")[1]}`,
    { type },
  );

  // Save raw file
  const rawExtension = BOTT_ATTACHMENT_TYPE_LOOKUP[type as BottAttachmentType]
    .toLowerCase();
  const rawPath = join(fileSystemRoot, `${attachmentId}.raw.${rawExtension}`);

  console.debug(`Writing raw file: ${attachmentId}, type: ${type}`);
  Deno.writeFileSync(rawPath, data);

  // Generate compressed
  const compressedFile = await compressFile(
    rawFile,
    attachmentId,
  );

  // Save compressed file
  const compressedExtension = BOTT_ATTACHMENT_TYPE_LOOKUP[
    compressedFile.type as BottAttachmentType
  ].toLowerCase();
  const compressedPath = join(
    fileSystemRoot,
    `${attachmentId}.compressed.${compressedExtension}`,
  );

  console.debug(
    `Writing compressed file: ${attachmentId}, type: ${compressedFile.type}`,
  );
  Deno.writeFileSync(
    compressedPath,
    new Uint8Array(await compressedFile.arrayBuffer()),
  );

  return {
    id: attachmentId,
    type: compressedFile.type as BottAttachmentType,
    originalSource: sourceUrl,
    raw: {
      id: crypto.randomUUID(),
      path: rawPath,
      file: rawFile,
    },
    compressed: {
      id: crypto.randomUUID(),
      path: compressedPath,
      file: compressedFile,
    },
    parent: parentEvent,
  };
}

/**
 * Prepares an attachment from a File object by storing and compressing.
 * Sets originalSource to file:// URL of raw file.
 * @param file The File object (e.g., generated by Gemini)
 * @param parentEvent The parent event this attachment belongs to
 * @returns Fully prepared attachment with both raw and compressed files
 */
export async function prepareAttachmentFromFile(
  file: File,
  parentEvent: BottEvent,
): Promise<BottEventAttachment> {
  const fileSystemRoot = getFileSystemRoot();

  const [name] = file.name.split(".");

  const attachmentId = crypto.randomUUID();

  const type = file.type as BottAttachmentType;
  const rawExtension = BOTT_ATTACHMENT_TYPE_LOOKUP[type].toLowerCase();
  const rawFileName = `${
    name || UNNAMED_FILE_PREFIX
  }.${attachmentId}.raw.${rawExtension}`;
  const rawPath = join(fileSystemRoot, rawFileName);

  // Save raw file
  const rawData = new Uint8Array(await file.arrayBuffer());
  console.debug(`Writing raw file: ${rawFileName}, type: ${type}`);
  Deno.writeFileSync(rawPath, rawData);

  // Generate compressed
  const compressedFile = await compressFile(file, attachmentId);

  // Save compressed file
  const compressedExtension = BOTT_ATTACHMENT_TYPE_LOOKUP[
    compressedFile.type as BottAttachmentType
  ].toLowerCase();
  const compressedFileName = `${
    name || UNNAMED_FILE_PREFIX
  }.${attachmentId}.compressed.${compressedExtension}`;
  const compressedPath = join(fileSystemRoot, compressedFileName);

  console.debug(
    `Writing compressed file: ${compressedFileName}, type: ${compressedFile.type}`,
  );
  Deno.writeFileSync(
    compressedPath,
    new Uint8Array(await compressedFile.arrayBuffer()),
  );

  return {
    id: attachmentId,
    type,
    originalSource: new URL(`file://${rawPath}`),
    raw: {
      id: crypto.randomUUID(),
      path: rawPath,
      file,
    },
    compressed: {
      id: crypto.randomUUID(),
      path: compressedPath,
      file: compressedFile,
    },
    parent: parentEvent,
  };
}

function getFileSystemRoot() {
  Deno.mkdirSync(STORAGE_FILE_ROOT, { recursive: true });

  return STORAGE_FILE_ROOT;
}

/**
 * Compresses a file based on its type
 */
async function compressFile(
  rawFile: File,
  attachmentId: string,
): Promise<File> {
  switch (rawFile.type as BottAttachmentType) {
    case BottAttachmentType.TXT: {
      const textDecoder = new TextDecoder();
      let textContent = textDecoder.decode(await rawFile.arrayBuffer());
      const words = textContent.split(/\s+/);

      let data;
      if (words.length > STORAGE_FILE_WORD_LIMIT) {
        textContent = words.slice(0, STORAGE_FILE_WORD_LIMIT).join(" ") +
          "\n\n...(truncated)";
        data = new TextEncoder().encode(textContent);
      } else {
        data = await rawFile.arrayBuffer();
      }
      return new File([data], `${attachmentId}.compressed.md`, {
        type: BottAttachmentType.MD,
      });
    }
    case BottAttachmentType.HTML:
      return await prepareHtmlAsMarkdown(
        rawFile,
        attachmentId,
      );
    case BottAttachmentType.PNG:
    case BottAttachmentType.JPEG:
      return await prepareStaticImageAsWebp(
        rawFile,
        attachmentId,
      );
    case BottAttachmentType.MP3:
    case BottAttachmentType.WAV:
      return await prepareAudioAsOpus(
        rawFile,
        attachmentId,
      );
    case BottAttachmentType.GIF:
    case BottAttachmentType.MP4:
      return await prepareDynamicImageAsMp4(
        rawFile,
        attachmentId,
      );
    // TODO: compression
    case BottAttachmentType.PDF:
      return new File([rawFile], `${attachmentId}.compressed.pdf`, {
        type: BottAttachmentType.PDF,
      });
    default:
      throw new Error(`Unsupported source type: ${rawFile.type}`);
  }
}
